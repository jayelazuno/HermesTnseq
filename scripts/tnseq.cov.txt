
#!/bin/bash
#$ -N cov.tnseq.all
#$ -q UI,COE,BME-5335
#$ -cwd
#$ -j y
#$ -o cov.tnseq.all.log
#$ -pe smp 56
#$ -S /bin/bash
#$ -M jayelazuno@uiowa.edu

set -euo pipefail

# --- activate conda ---
source /old_Users/jayelazuno/miniforge3/etc/profile.d/conda.sh
conda activate tnseq

# ----------------- paths & params -----------------
THREADS=${NSLOTS:-1}
MAPQ=20

ALIGN="/Users/jayelazuno/workspace/HermesTnseq/alignment"
CLEAN="/Users/jayelazuno/workspace/HermesTnseq/alignment/alignment_cleaned"
REFS="/Users/jayelazuno/workspace/HermesTnseq/refs"
RESULTS="/Users/jayelazuno/workspace/HermesTnseq/results"

REF="${REFS}/Cg_BG2_genomic.fna"              # adjust if your ref filename differs
GFF="${REFS}/BG2_Cg_genomic.gff"              # original GFF3

mkdir -p "$CLEAN" "$RESULTS"

# --- genome length (once) ---
samtools faidx "$REF" >/dev/null 2>&1
GENOME_BP=$(awk '{L+=$2} END{print L}' "${REF}.fai")

# --- make genes.bed (once) ---
GENES_BED="${RESULTS}/genes.bed"
if [[ ! -s "$GENES_BED" ]]; then
  awk 'BEGIN{OFS="\t"} $3=="gene"{
    id=$9; if (match($9,/ID=([^;]+)/,a)) id=a[1];
    print $1,$4-1,$5,id,".",$7
  }' "$GFF" > "$GENES_BED"
fi

# ----------------- sample list -----------------
# Explicit BAMs you provided (note case sensitivity)
declare -A BAMS=(
  [cgla_298p1]="${ALIGN}/sorted.cgla_298p1.bam"
  [cgla_298p2]="${ALIGN}/sorted.cgla_298p2.bam"
  [Cgla_299p1]="${ALIGN}/sorted.Cgla_299p1.bam"
  [Cgla_299p2]="${ALIGN}/sorted.Cgla_299p2.bam"
  [Cgla_298H2O2p1]="${ALIGN}/sorted.Cgla_298H2O2p1.bam"
  [Cgla_298H2O2p2]="${ALIGN}/sorted.Cgla_298H2O2p2.bam"
  [Cgla_299H2O2p1]="${ALIGN}/sorted.Cgla_299H2O2p1.bam"
  [Cgla_299H2O2p2]="${ALIGN}/sorted.Cgla_299H2O2p2.bam"
)

# ----------------- helpers -----------------
# write per-sample CSV header once
SAMPLE_HEADER="sample,genome_bp,primary_mapped_mapq>=${MAPQ}_nondup,unique_sites,sites_per_kb,breadth_sites_over_genome,total_reads_on_sites,mean_reads_per_site,genes_hit_ge1_pct,genes_hit_ge5_pct,total_genes,clean_bam,sites_bed3,igv_bed"
UNION_HEADER="union_id,genome_bp,union_sites,sites_per_kb,breadth_sites_over_genome,genes_hit_ge1_pct,genes_hit_ge5_pct,total_genes,union_bed3"

SAMPLE_CSV="${RESULTS}/tnseq_samples_summary.csv"
UNION_CSV="${RESULTS}/tnseq_unions_summary.csv"

echo "$SAMPLE_HEADER" > "$SAMPLE_CSV"
echo "$UNION_HEADER"  > "$UNION_CSV"

# function: process one sample
process_sample () {
  local sample="$1"
  local inbam="${BAMS[$sample]}"

  [[ -s "$inbam" ]] || { echo "Missing BAM for $sample: $inbam" >&2; return 1; }

  local clean_bam="${CLEAN}/${sample}.clean.bam"
  local clean_bai="${clean_bam}.bai"
  local sites_bed3="${CLEAN}/${sample}.sites.bed3"
  local sites_bg="${CLEAN}/${sample}.sites.bedgraph"
  local sites_igv="${CLEAN}/${sample}.sites.igv.bed"

  # 1) clean BAM (primary, mapped, non-dup, MAPQ threshold)
  samtools view -@ "$THREADS" -b -q "$MAPQ" -F 0xD04 "$inbam" > "$clean_bam"
  samtools index -@ "$THREADS" "$clean_bam"

  local primary=$(samtools view -c "$clean_bam")

  # 2) 1-bp insertion sites (strand-aware to 5' base), unique sites
  bedtools bamtobed -i "$clean_bam" \
  | awk 'BEGIN{OFS="\t"}{ if($6=="+") print $1,$2,$2+1; else print $1,$3-1,$3 }' \
  | sort -k1,1 -k2,2n -k3,3n | uniq > "$sites_bed3"

  local sites=$(wc -l < "$sites_bed3")
  local sites_per_kb=$(awk -v S="$sites" -v G="$GENOME_BP" 'BEGIN{printf "%.3f", S/(G/1000.0)}')
  local breadth=$(awk -v S="$sites" -v G="$GENOME_BP" 'BEGIN{printf "%.6f", S/G}')

  # 3) reads per site (counts) -> bedGraph
  bedtools bamtobed -i "$clean_bam" \
  | awk 'BEGIN{OFS="\t"}{ if($6=="+") print $1,$2,$2+1; else print $1,$3-1,$3 }' \
  | sort -k1,1 -k2,2n -k3,3n \
  | bedtools groupby -g 1,2,3 -c 1 -o count > "$sites_bg"

  local total_reads_on_sites=$(awk '{s+=$4} END{print s+0}' "$sites_bg")
  local mean_reads_per_site=$(awk '{s+=$4} END{printf (NR? "%.3f":"0.000"), (NR?s/NR:0)}' "$sites_bg")

  # 4) gene hit percentages on unique sites
  read g1 g5 gtot <<< "$(bedtools intersect -a "$GENES_BED" -b "$sites_bed3" -c \
     | awk '{g1+=($7>=1); g5+=($7>=5); tot++} END{printf "%.1f %.1f %d",100*g1/tot,100*g5/tot,tot}')"

  # 5) IGV BED6 with capped score
  awk 'BEGIN{OFS="\t"}{score=$4; if(score>1000)score=1000; print $1,$2,$3,"ins",score,"."}' \
    "$sites_bg" > "$sites_igv"

  # 6) append to sample CSV
  echo "${sample},${GENOME_BP},${primary},${sites},${sites_per_kb},${breadth},${total_reads_on_sites},${mean_reads_per_site},${g1},${g5},${gtot},${clean_bam},${sites_bed3},${sites_igv}" >> "$SAMPLE_CSV"

  echo "[OK] ${sample}"
}

# function: build union for a replicate pair (expects two sample keys)
process_union () {
  local union_id="$1"
  local s1="$2"
  local s2="$3"

  local p1="${CLEAN}/${s1}.sites.bed3"
  local p2="${CLEAN}/${s2}.sites.bed3"
  [[ -s "$p1" && -s "$p2" ]] || { echo "Missing sites for union ${union_id}"; return 1; }

  local union_bed3="${RESULTS}/${union_id}.union.sites.bed3"

  # union of sites (unique positions)
  cat "$p1" "$p2" | sort -k1,1 -k2,2n -k3,3n | uniq > "$union_bed3"

  local sites=$(wc -l < "$union_bed3")
  local spk=$(awk -v S="$sites" -v G="$GENOME_BP" 'BEGIN{printf "%.3f", S/(G/1000.0)}')
  local brd=$(awk -v S="$sites" -v G="$GENOME_BP" 'BEGIN{printf "%.6f", S/G}')

  read g1 g5 gtot <<< "$(bedtools intersect -a "$GENES_BED" -b "$union_bed3" -c \
     | awk '{g1+=($7>=1); g5+=($7>=5); tot++} END{printf "%.1f %.1f %d",100*g1/tot,100*g5/tot,tot}')"

  echo "${union_id},${GENOME_BP},${sites},${spk},${brd},${g1},${g5},${gtot},${union_bed3}" >> "$UNION_CSV"
  echo "[OK] union ${union_id}"
}

# ----------------- run all samples -----------------
for sample in "${!BAMS[@]}"; do
  process_sample "$sample"
done

# ----------------- unions (pairs) -----------------
# define your replicate pairs (union IDs on the left)
process_union "cgla_298"        "cgla_298p1"      "cgla_298p2"
process_union "Cgla_299"        "Cgla_299p1"      "Cgla_299p2"
process_union "Cgla_298H2O2"    "Cgla_298H2O2p1"  "Cgla_298H2O2p2"
process_union "Cgla_299H2O2"    "Cgla_299H2O2p1"  "Cgla_299H2O2p2"

echo
echo "Per-sample CSV  -> ${SAMPLE_CSV}"
echo "Union CSV       -> ${UNION_CSV}"
echo "Clean outputs   -> ${CLEAN}"
echo "Done."

